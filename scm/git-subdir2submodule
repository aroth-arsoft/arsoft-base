#!/bin/bash

verbose=0
clone_bare=1
clone_git_to_dest=1
repo_git=''
repo_schema=''
subdir_list=''
outdir=''
force=0
config_file=''
subdir_num=0
submodule_init=0
submodule_add=0
submodule_add_origin=0
keep=0
declare -a subdir_array
declare -a subdir_converted_array
declare -a subdir_name_array
declare -a subdir_repo_array
declare -a subdir_repo_public_array

function usage()
{
    echo "git-subdir2submodule <gitrepo> <subdir0> [subdir1]"
    echo "    -h, --help         shows this help screen"
    echo "    -v, --verbose      enable verbose output"
    echo "    -f, --force        override existing git repository. can be dangerous!"
    echo "    --keep             keep temporary GIT repositories for troubleshooting."
    echo "    --init             initialize submodules in main GIT repository."
    echo "    --add              add submodules to main GIT repository."
    echo "    -o <dir>           specifies the output directory"
    echo "    --file <path>      text file which contains the submodule specifications."
    exit 0
}

function verbose_exec()
{
    [ $verbose -ne 0 ] && echo "$@"
    "$@"
}

function cleanup_repo()
{
	true
}

function relative_path()
{
	local source="$1"
	local target="$2"

	local common_part=$source
	local back=
	while [ "${target#$common_part}" = "${target}" ]; do
		common_part=$(dirname $common_part)
		back="../${back}"
	done

	echo "${back}${target#$common_part/}"
}

function git_shrink()
{
	local repodir="$1"
	
	pushd "$repodir" > /dev/null

	if [ -d "$repodir/.git/refs/original" ]; then
		rm -rf "$repodir/.git/refs/original"
	elif [ -d "$repodir/refs/original" ]; then
		rm -rf "$repodir/refs/original"
	fi
	if [ $RES -eq 0 ]; then
		git remote rm origin; RES=$?
		if [ $RES -ne 0 ]; then
			echo "Failed to remove origin from GIT repository $repodir" >&2
		fi
	fi
	
	if [ $RES -eq 0 ]; then
		git reflog expire --expire=now --all; RES=$?
		if [ $RES -ne 0 ]; then
			echo "Failed to clean up reflog for the GIT repository $repodir" >&2
		fi
	fi
	
	if [ $RES -eq 0 ]; then
		git gc --aggressive --prune=now; RES=$?
		if [ $RES -ne 0 ]; then
			echo "Garbage collection in GIT repository $repodir failed." >&2
		fi
	fi
	if [ $RES -eq 0 ]; then
		echo "GIT repository $repodir disk size reduced successfully."
	fi
	popd > /dev/null

	return $RES
}

function git_clone_and_shrink()
{
	local repodir="$1"
	local destdir="$2"

	pushd "$repodir" > /dev/null

	# cloning to reduce size
	git clone --no-hardlinks $bare_opt "$repodir" "$destdir"; RES=$?
	if [ $RES -eq 0 ]; then
		git_shrink "$destdir"; RES=$?
		if [ $RES -eq 0 ]; then
			echo "Repository cloned from $repodir to $destdir"
		else
			echo "Failed to shirnk GIT repository $destdir." >&2
		fi
	else
		echo "Cloning of the GIT repository $repodir failed." >&2
	fi
	popd > /dev/null

	return $RES
}

function subdir_to_submodule()
{
	local repodir="$1"
	local subdir="$2"
	local destdir="$3"
	if [ -d "$destdir" ]; then
		if [ $force -eq 0 ]; then
			if [ $keep -ne 0 ]; then
				echo "Target directory already exists $destdir, but assume this is ok and just use it." >&2
				return 0
			else
				echo "Target directory already exists $destdir." >&2
				return 1
			fi
		else
			echo "Target directory already exists $destdir. Remove it and continue" >&2
			rm -rf "$destdir"
		fi
	else
		echo "Target directory does not exists $destdir." >&2
	fi

	[ $clone_bare -ne 0 ] && bare_opt='--bare' || bare_opt=''

	subdir_git_dir=`mktemp -d "$destdir.XXXXXX"`
	pushd "$subdir_git_dir" > /dev/null
	git clone --no-hardlinks $bare_opt "$repodir" "$subdir_git_dir"; RES=$?
	if [ $RES -eq 0 ]; then
		git filter-branch --subdirectory-filter "$subdir" --prune-empty HEAD -- --all; RES=$?
		if [ $RES -eq 0 ]; then
			if [ $clone_bare -eq 0 ]; then
				git reset --hard; RES=$?
				if [ $RES -ne 0 ]; then
					echo "Reset the GIT repository $subdir_git_dir failed." >&2
				fi
			fi
			if [ $RES -eq 0 ]; then
				git_shrink "$subdir_git_dir"; RES=$?
				if [ $RES -eq 0 ]; then
					echo "Subdirectory successfully converted into $subdir_git_dir."
				else
					echo "Failed to reduce size of GIT repository $subdir_git_dir." >&2
				fi
			fi
		else
			echo "Filter branch to GIT repository $subdir_git_dir failed" >&2
		fi
	else
		echo "Failed to clone GIT repository $repodir to $subdir_git_dir" >&2
	fi

	popd > /dev/null
	
	if [ $RES -eq 0 ]; then
		for ((idx=0; idx < $subdir_num ; idx++)); do
			current_subdir=${subdir_array[$idx]}
			if [ "$subdir" == "$current_subdir" ]; then
				subdir_converted_array[$idx]=1
				break
			fi
		done

		if [ $clone_git_to_dest -ne 0 ]; then
			# final cloning to reduce size
			echo "Cloning $subdir_git_dir to $destdir"
			git_clone_and_shrink "$subdir_git_dir" "$destdir"; RES=$?
			if [ $RES -eq 0 ]; then
				echo "Subdirectory cloned from $subdir_git_dir to $destdir"
			else
				echo "Final cloning the GIT repository $subdir_git_dir failed." >&2
			fi

			# remove the temporary clone of GIT repo
			rm -rf "$subdir_git_dir"
		else
			mv "$subdir_git_dir" "$destdir"
			echo "Subdirectory moved from $subdir_git_dir to $destdir"
		fi
	else
		# remove the temporary clone of GIT repo
		rm -rf "$subdir_git_dir"
	fi
	return $RES
}

function fully_remove_subdir()
{
	local repodir="$1"
	shift
	local subdirs="$@"
	pushd "$repodir" > /dev/null

	#git filter-branch --tree-filter 'git rm -r -f --ignore-unmatch *.pyc' HEAD
	git filter-branch -f --index-filter "git rm -qrf --cached --ignore-unmatch $subdirs" --prune-empty HEAD; RES=$?
	if [ $RES -eq 0 ]; then
		if [ -d "$repodir/.git/refs/original" ]; then
			rm -rf "$repodir/.git/refs/original"
		elif [ -d "$repodir/refs/original" ]; then
			rm -rf "$repodir/refs/original"
		fi
		git reflog expire --all; RES=$?
		if [ $RES -eq 0 ]; then
			git gc --aggressive --prune; RES=$?
			if [ $RES -eq 0 ]; then
				echo "Successfully removed $subdirs from GIT repository $repodir"
			else
				echo "Garbage collection in GIT repository $repodir failed." >&2
			fi
		else
			echo "Failed to expire reflog information in GIT repository $repodir." >&2
		fi
	else
		echo "Failed to filter subdirectories $subdirs from GIT repository $repodir." >&2
	fi
	
	if [ $RES -eq 0 ]; then
		# remove the subdirectory if it still exists
		for subdir in $subdirs; do
			[ -d "$repodir/$subdir" ] && rm -rf "$repodir/$subdir"
		done
	fi
	
	popd > /dev/null
	return $RES
}

function add_submodule()
{
	local repodir="$1"
	local path="$2"
	local submodule_repo="$3"
	
	pushd "$repodir" > /dev/null

	git submodule add --force "$submodule_repo" "$path"; RES=$?
	if [ $RES -eq 0 ]; then
		# stash the modified .gitmodules
		git add "${repodir}/.gitmodules"; RES=$?
		if [ $RES -eq 0 ]; then
			echo "Submodule $submodule_repo as $path successfully added."
		else
			echo "Failed to add ${repodir}/.gitmodules" >&2
		fi
	else
		echo "Failed to add submodule $subdir as $submodule_repo." >&2
	fi

	popd > /dev/null
	return $RES
}

# parse command line arguments
while [ $# -ne 0 ]; do
    case "$1" in
		'-?'|'-h'|'--help') usage;;
		'-v'|'--verbose') verbose=1; ;;
		'-f'|'--force') force=1; ;;
		'--keep') keep=1; ;;
		'--add') submodule_add=1; ;;
		'--init') submodule_add=1; submodule_init=1; ;;
		'-o') outdir="$2"; shift; ;;
		'--file') config_file="$2"; shift; ;;
		-*)
			echo "Invalid option $1 specified." >&2
			exit 1
			;;
        *)
			if [ -z "$repo_git" ]; then
				repo_git="$1"
			else
				[ -z "$subdir_list" ] && subdir_list="$1" || subdir_list="$subdir_list $1"
			fi
            ;;
    esac
    shift
done

script_file=`readlink -f "$0"`
script_dir=`dirname "$script_file"`
script_name=`basename "$script_file"`

if [ ! -x "/usr/bin/git" ]; then
	echo "GIT not installed. Please install using 'sudo apt-get install git-core'." >&2
	exit 1
fi

if [ -z "$repo_git" ]; then
	echo "No GIT repository specified." >&2
	exit 1
else
	if [ -d "$repo_git" ]; then
		repo_git=`readlink -f "$repo_git"`
		repo_schema='file'
	else
		repo_schema="${repo_git%://*}"
	fi
fi

[ -z "$outdir" ] && outdir=`readlink -f $(pwd)`

if [ ! -z "$config_file" ]; then
	subdir_num=0
	declare -a fields
	while IFS=$'\t ' read -r -a fields; do
		[ ${#fields[*]} -eq 0 -o "${fields[0]:0:1}" == "#" ] && continue
		
		subdir="${fields[0]}"

		subdir_safe=${subdir//\//_}

		[ ${#fields[*]} -gt 1 ] && subdir_name="${fields[1]}" || subdir_name="$subdir_safe"
		subdir_name_safe=${subdir_name//\//_}
		[ $clone_bare -ne 0 ] && subdir_git_dir="$outdir/${subdir_name_safe}.git" || subdir_git_dir="$outdir/${subdir_name_safe}"
		echo "subdir_git_dir=$subdir_git_dir"

		[ ${#fields[*]} -gt 2 ] && subdir_repo_public="${fields[2]}" || subdir_repo_public="$subdir_git_dir"

		subdir_array[$subdir_num]="$subdir"
		subdir_converted_array[$subdir_num]=0
		subdir_name_array[$subdir_num]="$subdir_name"
		subdir_repo_array[$subdir_num]="$subdir_git_dir"
		subdir_repo_public_array[$subdir_num]="$subdir_repo_public"
		let subdir_num++
	done < "$config_file"

	if [ $subdir_num -eq 0  ]; then
		echo "No subdirectory is loaded from $config_file." >&2
		exit 1
	fi
else
	if [ -z "$subdir_list" ]; then
		echo "No subdirectory in GIT repository specified." >&2
		exit 1
	else
		subdir_num=0
		for subdir in $subdir_list; do
			subdir_safe=${subdir//\//_}
			[ $clone_bare -ne 0 ] && subdir_git_dir="$outdir/${subdir_safe}.git" || subdir_git_dir="$outdir/${subdir_safe}"
		
			subdir_array[$subdir_num]="$subdir"
			subdir_converted_array[$subdir_num]=0
			subdir_name_array[$subdir_num]="$subdir_safe"
			subdir_repo_array[$subdir_num]="$subdir_git_dir"
			subdir_repo_public_array[$subdir_num]="$subdir_git_dir"
			let subdir_num++
		done
	fi

fi

repo_name=`basename "$repo_git" '.git'`
cloned_git_dir="$outdir/${repo_name}.git"

echo "GIT repository: $repo_git"
echo "GIT repository name: $repo_name"
echo "Output directory: $outdir"
echo "Subdirectory config: $config_file"
echo "Main repository: $cloned_git_dir"

if [ $verbose -ne 0 -o 1 ]; then
	for ((idx=0; idx < $subdir_num ; idx++)); do
		subdir=${subdir_array[$idx]}
		subdir_name=${subdir_name_array[$idx]}
		subdir_repo=${subdir_repo_array[$idx]}
		subdir_repo_public=${subdir_repo_public_array[$idx]}
		echo "subdir: $subdir"
		echo "subdir name: $subdir_name"
		echo "subdir repo: $subdir_repo"
		echo "subdir repo public: $subdir_repo_public"
		
		rel_path=$(relative_path $cloned_git_dir $subdir_repo)
		echo "subdir rel repo: $rel_path"
	done
fi

if [ $submodule_add -eq 0 ]; then
	[ $clone_bare -ne 0 ] && bare_opt='--bare' || bare_opt=''
else
	bare_opt=''
fi

exit 0

if [ $keep -ne 0 ]; then
	if [ -d "$cloned_git_dir" ]; then
		temp_git_dir="$cloned_git_dir"
		RES=0
	else
		temp_git_dir=`mktemp -d "$cloned_git_dir.XXXXXX"`
		git clone --no-hardlinks $bare_opt "$repo_git" "$temp_git_dir"; RES=$?
	fi
else
	temp_git_dir=`mktemp -d "$cloned_git_dir.XXXXXX"`
	git clone --no-hardlinks $bare_opt "$repo_git" "$temp_git_dir"; RES=$?
fi
if [ $RES -eq 0 ]; then
	# enter the cloned GIT repository
	pushd "$temp_git_dir" > /dev/null

	# create extra GIT repositories for each subdir
	for ((idx=0; idx < $subdir_num ; idx++)); do
		subdir=${subdir_array[$idx]}
		subdir_name=${subdir_name_array[$idx]}
		subdir_repo=${subdir_repo_array[$idx]}

		subdir_to_submodule "$temp_git_dir" "$subdir" "$subdir_repo"; RES=$?
		if [ $RES -eq 0 ]; then
			echo "GIT repository for $subdir successfully created."
		else
			echo "Failed to convert subdirectory $subdir." >&2
			break;
		fi
	done
	
	if [ $RES -eq 0 ]; then
		subdirs_to_remove=''
		# remove the subdirs from the cloned GIT repository
		for ((idx=0; idx < $subdir_num ; idx++)); do
			subdir=${subdir_array[$idx]}
			converted=${subdir_converted_array[$idx]}
			
			if [ $converted -ne 0 ]; then
				subdirs_to_remove="$subdirs_to_remove \"$subdir\""
			else
				echo "Subdirectory $subdir already removed."
			fi
		done
		
		if [ ! -z "$subdirs_to_remove" ]; then
			fully_remove_subdir "$temp_git_dir" $subdirs_to_remove; RES=$?
			if [ $RES -eq 0 ]; then
				echo "Subdirectories $subdirs_to_remove successfully removed."
			else
				echo "Failed to remove subdirectories $subdirs_to_remove." >&2
			fi
		fi
	fi

	if [ $submodule_add -ne 0 ]; then
		if [ $RES -eq 0 ]; then
			# re-add the subdirs as submodules from the cloned GIT repository
			for ((idx=0; idx < $subdir_num ; idx++)); do
				subdir=${subdir_array[$idx]}
				subdir_name=${subdir_name_array[$idx]}
				subdir_repo=${subdir_repo_array[$idx]}

				add_submodule "$temp_git_dir" "$subdir" "$subdir_repo"; RES=$?
				if [ $RES -eq 0 ]; then
					echo "Submodule $subdir successfully added."
				else
					echo "Failed to add submodule $subdir as $subdir_repo." >&2
					break;
				fi
			done
		fi
	fi

	if [ $submodule_init -ne 0 ]; then
		if [ $RES -eq 0 ]; then
			git submodule init; RES=$?
			if [ $RES -eq 0 ]; then
				git submodule update; RES=$?
				if [ $RES -eq 0 ]; then
					echo "New submodules initialized and updated successfully."
				else
					echo "Failed to update submodules." >&2
				fi
			else
				echo "Failed to initialize submodules." >&2
			fi
		fi
	fi

	if [ $submodule_add -ne 0 ]; then
		if [ $RES -eq 0 ]; then
			commit_msg_file=`mktemp`
			echo "$script_name converted the following subdirectories into submodules:" >> "$commit_msg_file"
			for ((idx=0; idx < $subdir_num ; idx++)); do
				subdir=${subdir_array[$idx]}
				subdir_name=${subdir_name_array[$idx]}
				subdir_repo_public=${subdir_repo_public_array[$idx]}
				echo "  $subdir -> $subdir_repo_public" >> "$commit_msg_file"
			done
			git commit -F "$commit_msg_file"; RES=$?
			rm "$commit_msg_file"
			if [ $RES -eq 0 ]; then
				echo "Submodule modifications commited."
			else
				echo "Failed to commit submodule modifications." >&2
			fi
		else
			echo "Failed to update submodules." >&2
		fi
	fi
	
	# leave the cloned GIT repository
	popd > /dev/null
	
	if [ $RES -eq 0 ]; then
		if [ "$temp_git_dir" != "$cloned_git_dir" ]; then
			git_clone_and_shrink "$temp_git_dir" "$cloned_git_dir"; RES=$?
		else
			RES=0
		fi
		# remove the temporary clone of GIT repo
		rm -rf "$temp_git_dir"

		if [ $RES -eq 0 ]; then
			echo "Conversion completed successfully."
			echo "Main repository is available at $cloned_git_dir"
			echo "Repositories for subdirectories:"
			show_todo=0
			for ((idx=0; idx < $subdir_num ; idx++)); do
				subdir=${subdir_array[$idx]}
				subdir_name=${subdir_name_array[$idx]}
				subdir_repo=${subdir_repo_array[$idx]}
				subdir_repo_public=${subdir_repo_public_array[$idx]}
				if [ "$subdir_repo_public" != "$subdir_repo" ]; then
					echo "  $subdir_repo (as $subdir_repo_public)"
					show_todo=1
				else
					echo "  $subdir_repo"
				fi
			done
			
			if [ $show_todo -ne 0 ]; then
				echo "Further steps required:"
				for ((idx=0; idx < $subdir_num ; idx++)); do
					subdir=${subdir_array[$idx]}
					subdir_name=${subdir_name_array[$idx]}
					subdir_repo=${subdir_repo_array[$idx]}
					subdir_repo_public=${subdir_repo_public_array[$idx]}
					if [ "$subdir_repo_public" != "$subdir_repo" ]; then
						echo " - copy $subdir_repo to $subdir_repo_public"
					fi
				done
			fi
		else
			echo "Failed to move temporary GIT repository $temp_git_dir to $cloned_git_dir." >&2
		fi
	else
		if [ $keep -ne 0 ]; then
			if [ "$temp_git_dir" != "$cloned_git_dir" ]; then
				mv "$temp_git_dir" "$cloned_git_dir"
			fi
			echo "Conversion failed, but keeping the main GIT repository at $cloned_git_dir"
		else
			echo "Conversion failed; remove temporary GIT repository at $temp_git_dir."
			# remove the temporary clone of GIT repo
			rm -rf "$temp_git_dir"
		fi
	fi
else
	echo "Failed to clone GIT repository $repodir to $subdir_git_dir" >&2
fi
