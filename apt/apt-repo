#!/bin/bash

verbose=0
action=''
package_files=''
copy_source=''
copy_dest=''
repo_dir=''
distribution=''
update_filelist=''
force=0

function usage() {
    echo "usage: apt-repo [options] <action> [params]"
    echo "available options:"
	echo "  -?,-h,--help           show this help message"
	echo "  -v,--verbose           enable verbose output of this script"
	echo "  -d,--distro <distro>   set the distribution name for the package"
	echo "  -f,--force             force the action. Be careful."
    echo "action must be one of the following:"
    echo "  add <debfile>          add a new package file"
    echo "  add <changesfile>      add a new packages from the changes file"
    echo "  remove <debfile>       removes the package file"
    echo "  remove <changesfile>   removes the packages from the changes file"
    echo "  init                   initialize/create a new repository"
    echo "  info                   status of the repository (default)"
    echo "  status                 same as info"
    echo "  cleanup                clean up the repository and delete unreferenced files"
    echo "  export                 re-export all pooled packages"
    echo "  update                 manually update the repository"
    echo "  cron-update [pkglist]  update the packages from the given list file or directory."
    echo "                         If no package list is specified all configured package lists are"
    echo "                         used."
    echo "  copy <from> <to> <pkg> copy package from one distrubution into another."
    exit 0
}

function repoInit() {
	[ ! -d "$repo_dir/conf" ] && mkdir -p "$repo_dir/conf"
	[ ! -d "$repo_dir/.gnupg" ] && mkdir -p "$repo_dir/.gnupg" && chmod 700 "$repo_dir/.gnupg"
	echo "basedir ." > "$repo_dir/conf/options"
	
	hostname=`hostname -f`
	codename=`lsb_release -cs`
	
	local gpg_homedir="$repo_dir/.gnupg"
	
    [ $verbose -ne 0 ] && echo "Generate GPG keys in $gpg_homedir"
	gpg2 --homedir "$gpg_homedir" --batch --gen-key <<EOF
Key-Type: default
Subkey-Type: default
Name-Real: APT Repository at $hostname
Name-Comment: APT Repository at $hostname
Name-Email: apt-repo@$hostname
Expire-Date: 0
%no-ask-passphrase
%pubring $repo_dir/.gnupg/pubring.gpg
%secring $repo_dir/.gnupg/secring.gpg
%commit
EOF
    [ $verbose -ne 0 ] && echo "Export GPG public key to $repo_dir/pubkey.asc"
	gpg2 --homedir "$gpg_homedir" --export --armor "apt-repo@$hostname" > "$repo_dir/pubkey.asc"
    [ $verbose -ne 0 ] && echo "Get key id of public key"
	generated_keyid=`gpg2 --homedir "$gpg_homedir" --list-secret-keys | awk  '/^sec/ { split($2,a,"/"); print a[2];}'`
    [ $verbose -ne 0 ] && echo "Key id of public key: $generated_keyid"

	cat  > "$repo_dir/conf/distributions" <<DISTRIBUTIONS_LINES
Origin: $hostname
Label: APT Repository for $codename
Codename: $codename
Architectures: i386 amd64 source
Components: main
Description: Private Repository
SignWith: $generated_keyid
DISTRIBUTIONS_LINES
}

function callReprepro() {
	local action="$1"
	shift
	REPREPRO_BASE_DIR=$repo_dir GNUPGHOME=$repo_dir/.gnupg /usr/bin/reprepro "$action" $@
	local RES=$?
	return $RES
}

function repoIsValid() {
	if [ ! -d "$repo_dir" ]; then
		echo "Directory $repo_dir does not exists." 1>&2
		return 1
	fi
	if [ ! -d "$repo_dir/dists" -o ! -d "$repo_dir/pool" ]; then
		echo "Directory $repo_dir does not hold a valid Debian repository." 1>&2
		return 1
	fi
	return 0
}

function repoStatus() {
	if callReprepro check; then
		[ $verbose -ne 0 ] && echo "Repository $repo_dir OK"
	else
		echo "Repository $repo_dir corrupt" 1>&2
	fi
}

function repoAdd() {
	local RES=1
	declare -a deb_files
	declare -a changes_files
	for f in $@; do
		if [ -f "$f" ]; then
			extension="${f##*.}"
			if [ "$extension" == "deb" ]; then
				deb_files+=($f)
			elif [ "$extension" == "changes" ]; then
				changes_files+=($f)
			fi
		fi
	done
	if [ ${#deb_files[@]} -ne 0 ]; then
		if callReprepro includedeb "$distribution" ${deb_files[*]}; then
			RES=0
			[ $verbose -ne 0 ] && echo "Packages ${deb_files[*]} added successfully."
		else
			echo "Failed to add packages ${deb_files[*]}." 1>&2
		fi
	fi
	if [ ${#changes_files[@]} -ne 0 ]; then
		if callReprepro includedeb "$distribution" ${changes_files[*]}; then
			RES=0
			[ $verbose -ne 0 ] && echo "Change files ${changes_files[*]} added successfully."
		else
			echo "Failed to add change files ${changes_files[*]}." 1>&2
		fi
	fi
	return $RES
}

function repoRemove() {
	local RES=1
	declare -a packages
	for f in $@; do
		packages+=($f)
	done
	if [ ${#packages[@]} -ne 0 ]; then
		if callReprepro remove "$distribution" ${packages[*]}; then
			RES=0
			[ $verbose -ne 0 ] && echo "Packages ${packages[*]} successfully removed."
		else
			echo "Failed to remove packages ${packages[*]}." 1>&2
		fi
	fi
	return $RES
}

function repoList() {
	local package_files="$@"
	if ! callReprepro ls "$package_files"; then
		echo "Failed to find any matches for $package_files" 1>&2
	fi
}

function repoCopy() {
    local source="$1"
    local dest="$2"
    shift;
    shift;
    local package_files="$@"
    echo "s=$source" "d=$dest" "p=$package_files"
    if ! callReprepro -VVV copy "$dest" "$source" "$package_files"; then
        echo "Failed to copy packages $package_files from $source to $dest" 1>&2
    fi
}

function debFileVersion() {
	local debfile="$1"

}

function repoIsPackageUpToDate() {
	local distro="$1"
	local package_file_path="$2"
	local package_file_package=`dpkg-deb -f "$package_file_path" Package`
	local package_file_version=`dpkg-deb -f "$package_file_path" Version`
	local package_file_arch=`dpkg-deb -f "$package_file_path" Architecture`
	local RES=1

	#echo "got $package_file_path -> $package_file_package, $package_file_version, $package_file_arch"

	declare -a fields
	local tmpfile=`mktemp`
	if callReprepro list "$distro" "$package_file_package" 2>/dev/null 1>"$tmpfile"; then
		while IFS=$'| :' read -r -a fields; do

			[ ${#fields[*]} -eq 0 ] && continue
			#echo "field=${fields[@]}"
			local repo_distro="${fields[0]}"
			local repo_component="${fields[1]}"
			local repo_arch="${fields[2]}"
			local repo_package="${fields[3]}"
			local repo_version="${fields[4]}"

			if [ "$repo_package" == "$package_file_package" -a "$repo_version" == "$package_file_version" -a "$repo_arch" == "$package_file_arch" ]; then
				[ $verbose -ne 0 ] && echo "Found package match $repo_package Version $repo_version ($repo_arch) for $repo_distro"
				RES=0
				break
			fi
		done < "$tmpfile"
	fi
	rm -rf "$tmpfile"
	return $RES
}

function repoDumpRefs() {
	if ! callReprepro dumpreferences; then
		echo "Failed to get complete package list" 1>&2
	fi
}

function repoUpdate() {
	if grep -E '^Update:' "$repo_dir/conf/distributions" 2>&1 1>/dev/null; then
		if ! callReprepro update; then
			echo "Failed to update repository $repo_dir" 1>&2
		fi
	fi
}

function repoProcessIncoming() {
	local ruleset="$1"
	[ -z "$ruleset" ] && ruleset='default'
	if [ -f "$repo_dir/conf/incoming" ]; then
		if ! callReprepro processincoming "$ruleset"; then
			echo "Failed to process incoming packages" 1>&2
		fi
	fi
}

function repoExport() {
    if ! callReprepro export; then
        echo "Failed to export package lists for repository" 1>&2
    fi
}

function repoCleanup() {
	if ! callReprepro clearvanished; then
		echo "Failed to clean up repository $repo_dir" 1>&2
	fi
}

function updateFile() {
	local source_url="$1"
	local distributions="${2//,/ }"
	local source_base=`basename "$1"`
	local dest_dir="$repo_dir/tmp"
	local dest_file="$dest_dir/$source_base"
	local old_mtime=0
	local source_query="${source_base##*\?}"
	source_query="${source_query//\//%2F}"

	#echo "source_query: $source_query"

	[ ! -d "$dest_dir" ] && mkdir -p "$dest_dir"
	[ -f "$dest_file" ] && old_mtime=`stat -c %Y "$dest_file"`
	pushd "$dest_dir" > /dev/null
	if [ $verbose -eq 0 ]; then
		wget --quiet --timestamping "$source_url" -nd
	else
		wget --verbose --timestamping "$source_url" -nd
	fi
	local RES=$?
	popd > /dev/null
	if [ $RES -eq 0 ]; then
		new_mtime=`stat -c %Y "$dest_file"`
		if [ $force -ne 0 -o $new_mtime -gt $old_mtime ]; then
			[ $verbose -ne 0 ] && echo "Download $source_url to $dest_file (old $old_mtime, new $new_mtime)"

			for distro in $distributions; do
				if callReprepro --ignore=extension includedeb "$distro" "$dest_file"; then
					[ $verbose -ne 0 ] && echo "Packages $dest_file added for $distro successfully."
				else
					echo "Failed to add packages $dest_file for $distro."
				fi
			done
		else
			[ $verbose -ne 0 ] && echo "No newer version of $source_url as $dest_file (old $old_mtime, new $new_mtime)"
			for distro in $distributions; do
				if ! repoIsPackageUpToDate "$distro" "$dest_file"; then
					if callReprepro --ignore=extension includedeb "$distro" "$dest_file"; then
						[ $verbose -ne 0 ] && echo "Packages $dest_file added for $distro successfully."
					else
						echo "Failed to add packages $dest_file for $distro."
					fi
				fi
			done
			true
		fi
	else
		echo "Failed to download $source_url to $dest_file" 1>&2
	fi
}

function updateFromFilelist() {
	local filelist="$1"
	local RES=1
	[ -z "$filelist" ] && filelist="$repo_dir/conf/packages.filelist"
	if [ ! -f "$filelist" ]; then
		echo "Given $filelist does not exists." 1>&2
	elif [ ! -r "$filelist" ]; then
		echo "Unable to read $filelist" 1>&2
	else
		[ $verbose -ne 0 ] && echo "Use package list $filelist"
		declare -a fields
		while IFS=$'\t ' read -r -a fields; do
			[ ${#fields[*]} -eq 0 -o "${fields[0]:0:1}" == "#" ] && continue

			source_url="${fields[0]}"
			distributions="${fields[1]}"

			updateFile "$source_url" "$distributions"
		done < "$filelist"
		RES=0
	fi
	return $RES
}

function updateFromFilelistDir() {
	local filelist_dir="$1"
	local RES=0
	local LAST_RES=0
	[ -z "$filelist_dir" ] && filelist_dir="$repo_dir/conf/packages.filelist.d"
	if [ -d "$filelist_dir" ]; then
		for filelist_file in "$filelist_dir"/*; do
			updateFromFilelist "$filelist_file"; LAST_RES=$?
			[ $LAST_RES -ne 0 ] && RES=$LAST_RES
		done
	fi
	return $RES
}

# parse command line arguments
while [ $# -ne 0 ]; do
	case "$1" in
	'-?'|'-h'|'--help') usage;;
	'-v'|'--verbose') verbose=1; ;;
	'-d'|'--distro'|'--distribution') distribution=$2; shift; ;;
	'-f'|'--force') force=1; ;;
	'init')
		action='init'
		case "$2" in
			-*)
				break;
				;;
			*)
				if [ -z "$repo_dir" ]; then
					repo_dir=`readlink -f "$2"`
					shift
				fi
				;;
		esac
		;;
	'info'|'status')
		action='status'
		;;
	'cleanup')
		action='cleanup'
		;;
    'export')
        action='export'
        ;;
	'add')
		action='add';
		while [ $# -gt 1 ]; do
			case "$2" in
				-*)
					break;
					;;
				*)
					package_files="$package_files $2"
					shift;
					;;
			esac
		done
		;;
	'remove')
		action='remove';
		while [ $# -gt 1 ]; do
			case "$2" in
				-*)
					break;
					;;
				*)
					package_files="$package_files $2"
					shift;
					;;
			esac
		done
		;;
	'list'|'ls')
		action='list'
		while [ $# -gt 1 ]; do
			case "$2" in
				-*)
					break;
					;;
				*)
					package_files="$package_files $2"
					shift;
					;;
			esac
		done
		;;
	'cron-update')
		action='cron-update'
		while [ $# -gt 1 ]; do
			case "$2" in
				-*)
					break;
					;;
				*)
					if [ "$2" ]; then
						update_filelist=`readlink -f "$2"`
					else
						echo "Invalid parameter $2"
					fi
					shift;
					;;
			esac
		done
		;;
    'copy')
        action='copy'
        while [ $# -gt 1 ]; do
            case "$2" in
                -*)
                    break;
                    ;;
                *)
                    if [ -z "$copy_source" ]; then
                        copy_source="$2"
                    elif [ -z "$copy_dest" ]; then
                        copy_dest="$2"
                    else
                        package_files="$package_files $2"
                    fi
                    shift;
                    ;;
            esac
        done
        if [ -z "$copy_source" ]; then
            echo "No source distrubution specified for copy operation." 1>&2
        elif [ -z "$copy_dest" ]; then
            echo "No destination distrubution specified for copy operation." 1>&2
        fi
        ;;
	-*)
		echo "Unrecognized parameter $1" 1>&2
		exit 1
		;;
	*)
		if [ -d "$1" ]; then
			if [ -z "$repo_dir" ]; then
				repo_dir=`readlink -f "$1"`
			else
				echo "Repository directory ($repo_dir) already specified. Ignore $1" 1>&2
			fi
		else
			echo "Unrecognized parameter $1" 1>&2
			exit 1
		fi
		;;
	esac
	shift
done

if [ ! -x /usr/bin/reprepro ]; then
	echo "reprepro is not installed. Please install reprepro" 1>&2
	exit 1
fi

[ -z "$repo_dir" ] && repo_dir=`pwd`
[ -z $action ] && action='status'
[ -z $distribution ] && distribution=`lsb_release -cs`


if [ $verbose -ne 0 ]; then
	echo "Action $action"
	echo "Repository directory: $repo_dir"
	if [ ! -z "$package_files" ]; then
		echo "Package files: $package_files"
	fi
fi

case "$action" in
	'init')
		repoInit
		;;
	'info'|'status')
		repoIsValid && repoStatus
		;;
	'cleanup')
		repoCleanup
		;;
    'export')
        repoExport
        ;;
	'add')
		repoAdd $package_files
		;;
	'remove')
		repoRemove $package_files
		;;
    'copy')
        repoCopy "$copy_source" "$copy_dest" $package_files
        ;;
	'list')
		if [ -z "$package_files" ]; then
			repoDumpRefs
		else
			repoList $package_files
		fi
		;;
	'cron-update'|'update')
		repoCleanup
		updateFromFilelistDir "$update_filelist"
		repoProcessIncoming
		repoUpdate
		;;
	*)
		echo "Action $action not implemented."
		;;
esac
