#!/usr/bin/python

import os
import platform
import shlex, subprocess
import argparse
import sys
import re
import io
import hashlib
from datetime import datetime, timedelta, tzinfo
from OpenSSL import crypto

__all__ = ["parse_date", "ParseError"]

# Adapted from http://delete.me.uk/2005/03/iso8601.html
ISO8601_REGEX = re.compile(r"(?P<year>[0-9]{4})((?P<month>[0-9]{2})((?P<day>[0-9]{2})"
    r"((?P<hour>[0-9]{2})(?P<minute>[0-9]{2})((?P<second>[0-9]{2})(\.(?P<fraction>[0-9]+))?)?"
    r"(?P<timezone>Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?"
)
TIMEZONE_REGEX = re.compile("(?P<prefix>[+-])(?P<hours>[0-9]{2}).(?P<minutes>[0-9]{2})")

class ParseError(Exception):
    """Raised when there is a problem parsing a date string"""

# Yoinked from python docs
ZERO = timedelta(0)
class Utc(tzinfo):
    """UTC
    
    """
    def utcoffset(self, dt):
        return ZERO

    def tzname(self, dt):
        return "UTC"

    def dst(self, dt):
        return ZERO
UTC = Utc()

class FixedOffset(tzinfo):
    """Fixed offset in hours and minutes from UTC
    
    """
    def __init__(self, offset_hours, offset_minutes, name):
        self.__offset = timedelta(hours=offset_hours, minutes=offset_minutes)
        self.__name = name

    def utcoffset(self, dt):
        return self.__offset

    def tzname(self, dt):
        return self.__name

    def dst(self, dt):
        return ZERO
    
    def __repr__(self):
        return "<FixedOffset %r>" % self.__name

def parse_timezone(tzstring, default_timezone=UTC):
    """Parses ISO 8601 time zone specs into tzinfo offsets
    
    """
    if tzstring == "Z":
        return default_timezone
    # This isn't strictly correct, but it's common to encounter dates without
    # timezones so I'll assume the default (which defaults to UTC).
    # Addresses issue 4.
    if tzstring is None:
        return default_timezone
    m = TIMEZONE_REGEX.match(tzstring)
    prefix, hours, minutes = m.groups()
    hours, minutes = int(hours), int(minutes)
    if prefix == "-":
        hours = -hours
        minutes = -minutes
    return FixedOffset(hours, minutes, tzstring)

def parse_date(datestring, default_timezone=UTC):
    """Parses ISO 8601 dates into datetime objects
    
    The timezone is parsed from the date string. However it is quite common to
    have dates without a timezone (not strictly correct). In this case the
    default timezone specified in default_timezone is used. This is UTC by
    default.
    """
    if not isinstance(datestring, basestring):
        raise ParseError("Expecting a string %r" % datestring)
    m = ISO8601_REGEX.match(datestring)
    if not m:
        raise ParseError("Unable to parse date string %r" % datestring)
    groups = m.groupdict()
    tz = parse_timezone(groups["timezone"], default_timezone=default_timezone)
    if groups["fraction"] is None:
        groups["fraction"] = 0
    else:
        groups["fraction"] = int(float("0.%s" % groups["fraction"]) * 1e6)
    return datetime(int(groups["year"]), int(groups["month"]), int(groups["day"]),
        int(groups["hour"]), int(groups["minute"]), int(groups["second"]),
        int(groups["fraction"]), tz)
        
    
class PEMItem(object):
    def __init__(self, blockindex, blocktype, blockdata):
        self.blockindex = blockindex
        self.blocktype = blocktype
        self.blockdata = blockdata
        
    def write(self, fobj):
        fobj.write(self.blockdata)
        
    def getHash(self):
        m = hashlib.md5()
        m.update(self.blockdata)
        return m.hexdigest()
        
class PEMFile:
    def __init__(self, filename=None, passphrase=None):
        self.m_begin_or_end_pattern = re.compile('^-----(?P<cmd>BEGIN|END) (?P<type>[A-Za-z ]+)-----$')
        self.m_filename = filename
        self.m_passphrase = passphrase
        self.m_blocks = []
        
    def open(self, filename=None, passphrase=None):
        if filename is None:
            filename = self.m_filename
        if passphrase is None:
            passphrase = self.m_passphrase

        ret = False
        blockdata = ''
        blocktype = None
        lineno = 0
        try:
            f = open(filename, 'r')
            for line in f:
                result = self.m_begin_or_end_pattern.match(line)
                if result is not None:
                    cmd = result.group('cmd')
                    blocktype = result.group('type')
                    if cmd == "BEGIN":
                        # clear the cert buffer
                        blockdata = ''
                        blockdata += line
                    elif cmd == "END":
                        if blocktype:
                            blockdata += line
                            blockindex = len(self.m_blocks)
                            self.m_blocks.append( PEMItem(blockindex, blocktype, blockdata) )
                        # prepare for next cert
                        blocktype = None
                        blockdata = ''
                else:
                    if blocktype:
                        blockdata += line
                lineno = lineno + 1
            f.close()
            ret = True
        except:
            ret = False
            pass
        return ret
        
    def save(self, filename=None):
        if filename is None:
            filename = self.m_filename

        try:
            f = open(filename, 'w')
            for pemitem in self.m_blocks:
                pemitem.write(f)
            f.close()
            ret = True
        except:
            ret = False
            pass
        return ret
        
    def close(self):
        self.m_filename = None
        self.m_passphrase = None
        self.m_blocks = []
        
    def getBlocks(self, blocktype):
        ret = []
        for pemitem in self.m_blocks:
            if pemitem.blocktype == blocktype:
                ret.append(pemitem)
        return ret
        
    def appendBlock(self, blocktype, blockdata):
        blockindex = len(self.m_blocks)
        self.m_blocks.append( PEMItem(blockindex, blocktype, blockdata) )

    def append(self, pemitem):
        self.m_blocks.append( pemitem )
        
class Certificate(PEMItem):
    def __init__(self, pemitem):
        PEMItem.__init__(self, pemitem.blockindex, pemitem.blocktype, pemitem.blockdata)
        self.cert = crypto.load_certificate(crypto.FILETYPE_PEM, self.blockdata) 
        
    def update(self, newcert):
        if isinstance(newcert, Certificate):
            self.cert = newcert.cert
        else:
            self.cert = newcert
        self.blockdata = crypto.dump_certificate(crypto.FILETYPE_PEM, self.cert) 

    def is_same_cert(self, rhs_cert):
        lhs_issuer = self.cert.get_issuer()
        lhs_subject = self.cert.get_subject()
        rhs_issuer = rhs_cert.get_issuer()
        rhs_subject = rhs_cert.get_subject()
        
#        self._printName('  LHS Issuer:  ', lhs_issuer)
#        self._printName('  RHS Issuer:  ', rhs_issuer)
#        self._printName('  LHS Subject: ', lhs_subject)
#        self._printName('  RHS Subject: ', rhs_subject)
        
        return lhs_issuer.hash() == rhs_issuer.hash() and lhs_subject.hash() == rhs_subject.hash()
    
    def expires_later(self, rhs_cert):
        lhs_not_before = self.get_notBefore()
        lhs_not_after = self.get_notAfter()
        rhs_not_before = rhs_cert.get_notBefore()
        rhs_not_after = rhs_cert.get_notAfter()

        print('  LHS Not After:  ', lhs_not_after.ctime())
        print('  RHS Not After:  ', rhs_not_after.ctime())
        print('  LHS Not Before: ', lhs_not_before.ctime())
        print('  RHS Not Before: ', rhs_not_before.ctime())
        return lhs_not_after > rhs_not_after

    def _matchName(self, name, term):
        if term is None or term == 'all':
            ret = True
        else:
            ret = False
            for (key, value) in name.get_components():
                if value.count(term) != 0:
                    ret = True
                    break
        return ret

    def _matchCert(self, term):
        issuer = self.cert.get_issuer()
        subject = self.cert.get_subject()
        return self._matchName(issuer, term) or self._matchName(subject, term)

    def _is_identical_cert(self, rhs_cert):
        return self.is_same_cert(rhs_cert) and self.get_serial_number() == rhs_cert.get_serial_number()
        
    def get_subject(self):
        return self.cert.get_subject()

    def get_issuer(self):
        return self.cert.get_issuer()
        
    def get_version(self):
        return self.cert.get_version()

    def get_serial_number(self):
        return self.cert.get_serial_number()
        
    def has_expired(self):
        return self.cert.has_expired()

    def get_notBefore(self):
        return parse_date(self.cert.get_notBefore())
        
    def get_notAfter(self):
        return parse_date(self.cert.get_notAfter())
    
    def _writeName(self, fobj, prefix, name):
        text = ''
        for (key, value) in name.get_components():
            if len(text) != 0:
                text += ', '
            text += key + '=' + value
        fobj.write(prefix + text + '\n')
        
    def _writeNamePretty(self, fobj, label, name, indent=0):
        prefix = ' ' * indent
        
        where = ''
        if name.localityName:
            where = name.localityName
        if name.countryName:
            if len(where) != 0:
                where += ', '
            where += name.countryName
        if name.stateOrProvinceName:
            if len(where) != 0:
                where += ', '
            where += name.stateOrProvinceName
            
        org = ''
        if name.organizationName:
            org = name.organizationName
        if name.organizationalUnitName:
            if len(org) != 0:
                org += ', '
            org += name.organizationalUnitName
        if name.emailAddress:
            if len(org) != 0:
                org += ' '
            org += '(' + name.emailAddress + ')'

        fobj.write(prefix + label + unicode(name.commonName))
        if len(org):
            fobj.write(', ' + org)
        if len(where):
            fobj.write(' at ' + where)
        fobj.write('\n')
    
    def writePretty(self, fobj, indent=0, filename=None, certno=None, short=False):
        issuer = self.cert.get_issuer()
        serial = self.get_serial_number() 
        try:
            signature_algorithm = cert.get_signature_algorithm()
        except:
            signature_algorithm = 'Unknown'
        subject = self.get_subject()
        version = self.get_version()
        not_before = self.get_notBefore()
        not_after = self.get_notAfter()
        has_expired = self.cert.has_expired() 
        num_extension = self.cert.get_extension_count()
        # cert.get_extension(index) 
        
        prefix = ' ' * indent

        if short:
            fobj.write(filename + '\n')
        else:
            if filename:
                if certno:
                    fobj.write(prefix + "Certificate " + filename + " #" + str(certno) + ":\n")
                else:
                    fobj.write(prefix + "Certificate " + filename + ":\n")
            else:
                if certno:
                    fobj.write(prefix + "Certificate #" + str(certno) + ":\n")
                else:
                    fobj.write(prefix + "Certificate:\n")
            fobj.write(prefix + "  Hash: " + str(self.getHash()) + '\n')
            fobj.write(prefix + "  Version: " + str(version) + '\n')
            fobj.write(prefix + "  Serial Number: " + str(serial) + '\n')
            fobj.write(prefix + "  Signature Algorithm: " + str(signature_algorithm) + '\n')
            self._writeNamePretty(fobj, '  Issuer:  ', issuer)
            fobj.write(prefix + "  Validity" + '\n')
            fobj.write(prefix + "    Not Before: " + not_before.ctime() + '\n')
            fobj.write(prefix + "    Not After : " + not_after.ctime() + '\n')
            self._writeNamePretty(fobj, '  Subject: ', subject)
        
class CertificatePEMFile(PEMFile):
    def __init__(self, filename=None):
        PEMFile.__init__(self, filename)
        
    def getCertificates(self):
        ret = []
        i = 0
        while i < len(self.m_blocks):
            pemitem = self.m_blocks[i]
            if pemitem.blocktype == 'CERTIFICATE':
                cert = Certificate(pemitem)
                ret.append( cert )
            i = i + 1
        return ret

class CertificateList:
    def __init__(self):
        self.m_certificates = []
        
    def _getAllCertFilesInDir(self, dirname):
        ret = []
        exclude_dirs = ['.svn', 'CVS', '.git' ]
        cert_file_exts = ['.pem', '.crt' ]
        for direntry in os.listdir(dirname):
            fullname = os.path.join(dirname, direntry)
            if os.path.isdir(fullname):
                if not direntry in exclude_dirs:
                    ret.extend( self._getAllCertFilesInDir(fullname) )
            else:
                (basename, ext) = os.path.splitext(direntry)
                if ext in cert_file_exts:
                    ret.append(fullname)
        return ret

    def add(self, filename):
        if os.path.isdir(filename):
            self.addDirectory(filename)
        else:
            self.addFile(filename)
    
    def addFile(self, filename):
        pemfile = CertificatePEMFile(filename)
        if pemfile.open():
            for cert in pemfile.getCertificates():
                cert_tuple = (filename, cert)
                self.m_certificates.append(cert_tuple)
            ret = True
        else:
            ret = False
        return ret
    
    def addDirectory(self, dirname):
        ret = False
        dir_files = self._getAllCertFilesInDir(dirname)
        
        for file_in_dir in dir_files:
            if self.addFile(file_in_dir):
                ret = True
        return ret
        
    def save(self):
        ret = True
        # find all unique certfiles
        unique_files = {}
        for (certfile, cert) in self.m_certificates:
            if certfile in unique_files:
                unique_files[certfile].append(cert)
            else:
                unique_files[certfile] = [ cert ]
        
        for certfile, certlist in unique_files.iteritems():
            pemfile = PEMFile()
            for cert in certlist:
                pemfile.append(cert)
            ret = pemfile.save(certfile)
        return ret
        
    def write(self, fobj, expired_only=False, valid_only=False, output_number=True, short=False):
#        if not short:
 #           print("Certificates within " + ','.join(self.m_certificate_filename))

        num_certs = 0
        for (certfile, cert) in self.m_certificates:
            if expired_only:
                if cert.has_expired():
                    cert.writePretty(fobj, filename=certfile, certno=num_certs, short=short)
                    num_certs = num_certs + 1
            elif valid_only:
                if not cert.has_expired():
                    cert.writePretty(fobj, filename=certfile, certno=num_certs, short=short)
                    num_certs = num_certs + 1
            else:
                cert.writePretty(fobj, filename=certfile, certno=num_certs, short=short)
                num_certs = num_certs + 1

        if output_number and not short:
            fobj.write("Number of certificates: " + str(num_certs) + "\n")

    def find(self, term):
        ret = []
        for (certfile, cert) in self.m_certificates:
            if self._matchCert(cert, term):
                ret.append( (certfile, cert) )
        return ret
        
    def update(self, rhs):
        ret = 0
        for (certfile, cert) in self.m_certificates:
            for (rhs_certfile, rhs_cert) in rhs.m_certificates:
                if cert.is_same_cert(rhs_cert):
                    if rhs_cert.expires_later(cert):
                        #print(rhs_certfile + ' replaces ' + certfile)
                        cert.update(rhs_cert)
                        ret = ret + 1
        return ret

    def replace(self, term, newcert):
        ret = False
        for (certfile, cert) in self.m_certificates:
            if self._matchCert(cert, term):
                cert.update(newcert)
                ret = True
        return ret
        
class CertificateListFile:
    def __init__(self, filename=None):
        self.m_filename = filename
        self.m_lines = []

    def open(self, filename=None):
        if filename is None:
            filename = self.m_filename

        lineno = 0
        self.m_lines = []
        try:
            f = open(filename, 'r')
            for line in f:
                if line[0] == '#':
                    # it's a comment, so skip this line but keep it for later
                    # (comment, certfile, active)
                    line_obj = (True, line[1:].rstrip(), False)
                elif line[0] == '!':
                    line_obj = (False, line[1:].rstrip(), False)
                else:
                    line_obj = (False, line.rstrip(), True)

                self.m_lines.append(line_obj)
                lineno = lineno + 1
            f.close()
            ret = True
        except:
            ret = False
            pass
        return ret
        
    def save(self, filename=None):
        if filename is None:
            filename = self.m_filename

        try:
            f = open(filename, 'w')
            for (comment, certfile, active) in self.m_lines:
                if comment:
                    f.write('#' + certfile + '\n')
                else:
                    if active:
                        f.write(certfile + '\n')
                    else:
                        f.write('!' + certfile + '\n')
            f.close()
            ret = True
        except:
            ret = False
            pass
        return ret

    def enableCertificate(self, cert_filename, enable=True):
        i = 0
        ret = False
        while i < len(self.m_lines):
            (comment, current_cert_filename, active) = self.m_lines[i]
            if current_cert_filename == cert_filename:
                self.m_lines[i] = (comment, cert_filename, enable)
                ret = True
            i = i + 1
        return ret

    def addCertificate(self, cert_filename, enable=True):
        i = 0
        ret = False
        while i < len(self.m_lines):
            (comment, current_cert_filename, active) = self.m_lines[i]
            if current_cert_filename == cert_filename:
                self.m_lines[i] = (comment, cert_filename, enable)
                ret = True
            i = i + 1
        if not ret:
            cert_tuple = (comment, cert_filename, enable)
            self.m_lines.append( cert_tuple )
        return ret

    def removeCertificate(self, cert_filename):
        ret = False
        i = 0
        while i < len(self.m_lines):
            (comment, current_cert_filename, active) = self.m_lines[i]
            if current_cert_filename == cert_filename:
                self.m_lines.pop(i)
                ret = True
            i = i + 1
        return ret
    

class certinfo:
    def __init__(self):
        self.m_begin_or_end_pattern = re.compile('^-----(?P<cmd>BEGIN|END) (?P<type>CERTIFICATE|RSA PRIVATE KEY|RSA PUBLIC KEY|DSA PRIVATE KEY|DSA PUBLIC KEY|CERTIFICATE REQUEST|X509 CRL)-----$')
        self.m_verbose = False
        self.m_certificate_filename = None
        self.m_certificate_list_filename = None
        self.m_certificate_list = None

    def _loadCerts(self, cert_filenames):
        ret = False
        self.m_certificate_list = CertificateList()
        for certfile in cert_filenames:
            if self.m_certificate_list.add(certfile):
                ret = True
        return ret

    def find(self, term, output_number=True):
        num_certs = 0
        for (certfile, cert) in self.m_certificate_list.find(term):
            self.m_certificate_list.printCert(cert, filename=certfile)
            num_certs = num_certs + 1

        if output_number:
            print("Number of certificates: " + str(num_certs))

    def _addcertfile(self, cert_filename, directory=None, enable=True):
        (tmp, certs) = self._readCertFile(cert_filename)
        if len(certs) > 0:
            basename = os.path.basename(cert_filename)
            if directory is not None:
                dest_cert_filename = os.path.join('/usr/share/ca-certificates', directory, basename)
            else:
                dest_cert_filename = os.path.join('/usr/share/ca-certificates', basename)
            ret = self._writeCertFile(dest_cert_filename, certs)
            if ret:
                if directory is not None:
                    short_cert_filename = os.path.join(directory, basename)
                else:
                    short_cert_filename = basename
                    
                certlist = CertificateListFile(self.m_certificate_list_filename)
                if certlist.open():
                    certlist.addCertificate(short_cert_filename, enable)
                    ret = self.save()
                else:
                    ret = False
        else:
            ret = False
        return ret

    def _removecertfile(self, cert_filename, directory=None, enable=True):
        basename = os.path.basename(cert_filename)
        if directory is not None:
            dest_cert_filename = os.path.join('/usr/share/ca-certificates', directory, basename)
            short_cert_filename = os.path.join(directory, basename)
        else:
            dest_cert_filename = os.path.join('/usr/share/ca-certificates', basename)
            short_cert_filename = basename

        try:
            os.unlink(dest_cert_filename)
            ret = True
        except:
            ret = False
            pass
        if ret:
            certlist = CertificateListFile(self.m_certificate_list_filename)
            if certlist.open():
                certlist.removeCertificate(short_cert_filename)
                ret = self.save()
            else:
                ret = False
        return ret
        
    def _getFilenameForCert(self, cert, extension='.pem'):
        subject = cert.get_subject()
        serial = cert.get_serial_number() 
        ret = ('%08x' % serial) + '_' + str(subject.commonName) + extension
        ret = ret.replace(' ', '_')
        
        return ret

    def extract(self, term, outdir, expired_only=False, valid_only=True, output_number=True):
        if outdir is None:
            outdir = os.getcwd()

        num_certs = 0
        for (certfile, cert) in self.m_certificates:
            if self._matchCert(cert, term):
                perform_extract = False
                if expired_only:
                    if cert.has_expired():
                        perform_extract = True
                elif valid_only:
                    if not cert.has_expired():
                        perform_extract = True
                else:
                    perform_extract = True
                    
                if perform_extract:
                    cert_basename = self._getFilenameForCert(cert)
                
                    certfile = os.path.join(outdir, cert_basename)
                    print("extract to " + certfile)
                    self._writeCertFile(certfile, [cert] )
                    num_certs = num_certs + 1

        if output_number:
            print("Number of certificates: " + str(num_certs))
        return False
        
    def update(self, outdir, expired_only=False, valid_only=True, output_number=True):
        if outdir is None:
            outdir = os.getcwd()
            
        #print('outdir=' + outdir)
        outdir_certificate_list = CertificateList()
        outdir_certificate_list.add(outdir)
        
        #print('current certicates')
        #self.m_certificate_list.write(sys.stdout)
        #print('outdir certicates')
        #outdir_certificate_list.write(sys.stdout)
        
        #print('update certicates')
        num_updated = self.m_certificate_list.update(outdir_certificate_list)
        #print('updated certicates ' + str(num_updated) + ' and list:')
        #self.m_certificate_list.write(sys.stdout)
        
        ret = self.m_certificate_list.save()
        
        return ret

    def main(self):
        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='shows information about certificates')
        parser.add_argument('certfile', help='input certificate file or directory', metavar='certfile', nargs='+')
        parser.add_argument('--listfile', dest='listfile', help='input certificate list file', metavar='listfile')
        parser.add_argument('--verbose', dest='verbose', action='store_true', help='enable verbose output of this script.')
        parser.add_argument('--find', dest='findbyname', help='find a certificate by name', metavar='term')
        parser.add_argument('--expired', dest='list_expired', action='store_true', help='lists all expired ceritificates')
        parser.add_argument('--short', dest='short', action='store_true', help='lists only the certificate file names')
        parser.add_argument('--valid', dest='list_valid', action='store_true', help='lists only valid ceritificates')
        parser.add_argument('--add', dest='addcertfile', help='add the given certificate file', metavar='certfile')
        parser.add_argument('--remove', dest='removecertfile', help='remove the given certificate file', metavar='certfile')
        parser.add_argument('--outdir', dest='outdir', help='specifies the output directory', metavar='dir')
        parser.add_argument('--extract', dest='extract', help='extracts all matching certicates into separate files', metavar='term')
        parser.add_argument('--update', dest='update', help='updates all certificates from the specified certificates', metavar='file')

        args = parser.parse_args()

        self.m_verbose = args.verbose
        
        if args.certfile is None:
            self.m_certificate_filename = [ '/etc/ssl/certs/ca-certificates.crt' ]
        else:
            self.m_certificate_filename = args.certfile
            
        if args.listfile is None:
            self.m_certificate_list_filename = '/etc/ca-certificates.conf'
        else:
            self.m_certificate_list_filename = args.listfile
        
        if args.addcertfile:
            self._addcertificate(args.addcertfile)
        elif args.removecertfile:
            self._removeCertificate(args.removecertfile)
        else:
            self._loadCerts(self.m_certificate_filename)

        if args.findbyname:
            self.find(args.findbyname, short=args.short)
        elif args.extract:
            self.extract(args.extract, args.outdir)
        elif args.update:
            self.update(args.update)
        else:
            if args.list_expired:
                self.m_certificate_list.write(sys.stdout, expired_only=True, short=args.short)
            elif args.list_valid:
                self.m_certificate_list.write(sys.stdout, valid_only=True, short=args.short)
            else:
                self.m_certificate_list.write(sys.stdout, short=args.short)

if __name__ == "__main__":
    app =  certinfo()
    app.main()
